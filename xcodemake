#!/usr/bin/env perl -w
#
# "xcodemake"
#
# A short script to convert xcodebuild output into a Makefile.
# Once a Makefile has been generated you can use the much
# faster "make" command for most builds instead of launching
# the more ponderous xcodebuild for each iteration. Sure,
# this could be rewritten in python and use ninja instead.
#

use IO::File;
use strict;

my $log = "xcodebuild @ARGV.log";
my $make = "Makefile";

if (! -f $log) {
    # Move Xcode's build database to one side to
    # be able to use xcodebuild inside a scheme.
    my $builddb = $ENV{OBJROOT};
    if ($builddb) {
        $builddb .= "/XCBuildData/build.db";
        rename $builddb, $builddb.".save";
    }

    my $xcodebin = $ENV{DEVELOPER_BIN_DIR}||'/usr/bin';
    my $archs = $ENV{ARCHS}||'arm64';
    my $args = join ' ', map { "'$_'" } @ARGV;
    $args .= " -config Debug" if $args !~ /-config/;
    my $build = "'$xcodebin'/xcodebuild clean; /usr/bin/env -i '$xcodebin'/xcodebuild ARCHS=$archs $args 2>&1 | tee '$log'";
    warn "Executing: $build\n";
    if (system $build) {
        unlink $log;
        exit 1;
    }
    unlink $make;
    
    rename $builddb.".save", $builddb if $builddb;
}

# Regenerate Makefile (if script newer)
generateMakefile() if ! -f $make or -M $0 < -M $make
    || !`grep 'xcodemake @ARGV' Makefile`;

exit system("make") >> 8;

my ($LOG, $fileArg);
sub generateMakefile {
$LOG = IO::File->new("< $log") or die "Could not open $log: $!";

# regex for file path argument
my $notSpace = "[^\\\\\\s]";
$fileArg = "$notSpace+(?:\\\\.$notSpace*)*";

sub escape {
    $_[1] =~ s/([$_[0]])/\\$1/g;
}
sub unescape {
    $_[1] =~ s/\\([$_[0]])/$1/g;
}

# escape $ for make
sub dollarEscape {
    $_[0] =~ s/\\\$/\\\$\$/g;
}
# escape file path
sub shellEscape {
    escape "()", $_[0];
    dollarEscape $_[0];
}

sub nextLine {
    my $line = $LOG->getline() or return;
    chomp $line;
    return $line;
}

sub nextCD {
    my ($cd) = nextLine() =~ /cd (.*)/;
    unescape "^\$'()&", $cd;
    escape " ", $cd;
    dollarEscape $cd;
    return "\t\tcd $cd\n\t\t/usr/bin/time ";
}

# Extract values for the option from a command
sub extractOption {
    my ($line, $option) = @_;
    return my @a = $line =~ / $option ($fileArg)/g;
}

my $identity = $ENV{EXPANDED_CODE_SIGN_IDENTITY} || '-';
my $MAKE = IO::File->new("> $make") or die "Could not open $make: $!";
print $MAKE <<HEADER;
#
# Generated @{[scalar localtime()]}
# xcodemake @ARGV
#

default: main

HEADER

my (%rules, @linked, @codesigns);
while (defined(my $line = nextLine())) {
    print $MAKE "# $line\n";
    # Add rules for "C" family sources.
    if (my ($object, $source) = $line =~
        /^CompileC ($fileArg) ($fileArg) /) {
        my $cd = nextCD();
        do {
            $line = nextLine();
        } while ($line =~ /^\s*$|response file/);
        unescape "{}()", $object;
        escape "\$&", $object;
        dollarEscape $source;
        unescape "'", $source;
        print $MAKE "\n$object: $source\n";
        shellEscape $object;
        dollarEscape $line;
        print $MAKE "$cd$line && touch $object\n\n";
    # Add rules for Swift sources (expand batches)
    } elsif ($line =~ /^SwiftCompile \w+ \w+/) {
        my $cd = nextCD();
        ($line = nextLine()) =~
            s/builtin-swiftTaskExecution -- |-frontend-parseable-output//g;
        my @sources = extractOption($line, "-primary-file")
            or warn "Release/Whole module optimization not permitted: $line";
        my @objects = extractOption($line, "-o");
        # print "# $line\n@sources -- @objects\n\n";
        dollarEscape $line;
        foreach my $i (0..$#sources) {
            unescape "{}()", my $object = $objects[$i];
            unescape "\$'&{}()*", $sources[$i];
            $sources[$i] =~ s/\$/\$\$/g;
            next if $rules{$object}++;
            print $MAKE "\n$object: $sources[$i]\n";
            shellEscape $object;
            print $MAKE "$cd$line && touch $object\n\n";
        }
    # Add rule to link executables
    } elsif (my ($executable) = $line =~ /^Ld ($fileArg) /) {
        my $cd = nextCD();
        $line = nextLine();
        my ($linkfile) = extractOption($line, "-filelist") or next;
        $linkfile =~ s/\\(.)/$1/g;
        print("Link file for $executable: $linkfile\n");
        my $OBJS = IO::File->new("< $linkfile") || IO::File->new("< /dev/null");
        escape "&\$", $executable;
        print $MAKE "\n$executable:";
        while (my $object = $OBJS->getline()) {
            chomp $object;
            escape " '&\$", $object;
            next if $object eq $executable || !$rules{$object};
            print $MAKE " $object";
        }
        dollarEscape $line;
        print $MAKE "\n$cd$line\n\n";
        push @linked, $executable if $executable !~ /\.o$/;
    } elsif ($line =~ m@^    /usr/bin/(codesign|touch)@) {
        dollarEscape $line;
        push @codesigns, $line;
    }
}

print $MAKE "main: @linked\n";
print $MAKE join "\n", map {"\t$_"} @codesigns;
print $MAKE "\n";
close $MAKE;
}
