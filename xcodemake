#!/usr/bin/env perl -w
#
# "xcodemake"
#
# A short script to convert xcodebuild output into a Makefile.
# Once a Makefile has been generated you can use the much
# faster "make" command for most builds instead of launching
# the more ponderous xcodebuild for each iteration. Sure,
# this could be rewritten in python and use ninja instead.
#

use IO::File;
use strict;

my $log = "xcodebuild.log";
my $make = "Makefile";

if (! -f $log) {
    # Move Xcode's build database to one side so
    # you can use xcodebuild inside a scheme.
    my $builddb = $ENV{OBJROOT};
    if ($builddb) {
        $builddb .= "/XCBuildData/build.db";
        rename $builddb, $builddb.".save";
    }

    my $xcodebin = $ENV{DEVELOPER_BIN_DIR}||'/usr/bin';
    my $archs = $ENV{ARCHS}||'arm64';
    my $build = "'$xcodebin'/xcodebuild clean; /usr/bin/env -i '$xcodebin'/xcodebuild ARCHS=$archs @ARGV 2>&1 | tee $log";
    print "$build\n";
    system $build;
    unlink $make;
    
    rename $builddb.".save", $builddb if $builddb;
}

# Regenerate Makefile (if script newer)
if (! -f $make or -M $0 < -M $make) {
my $LOG = IO::File->new("< $log") or die "Could not open $log: $!";
my $MAKE = IO::File->new("> $make") or die "Could not open $make: $!";
print $MAKE "\ndefault: main\n\n";

sub nextLine {
    my $line = $LOG->getline() or return;
    chomp $line;
    return $line;
}

# Extract values for the option from a command
sub extractOption {
    my ($line, $option) = @_;
    return my @out = $line =~ / $option ([^\\\s]+(?:\\.[^\\\s]+)*)/g;
}

my (%rules, @linked);

while (defined(my $line = nextLine())) {
    chomp $line;
    print $MAKE "# $line\n";
    # Add rules for "C" family sources.
    if (my ($object, $source) = $line =~
        /^CompileC (\S+?(?:\\.\S+?)*?) (\S+?(?:\\.\S+?)*?) /) {
        my $cd = nextLine();
        do {
            $line = nextLine();
        } while ($line =~ /^\s*$|response file/);
        print $MAKE "\n$object: $source\n";
        print $MAKE "\t$cd\n\t$line && touch $object\n\n";
    # Add rules for Swift sources (expand batches)
    } elsif ($line =~ /^SwiftCompile \w+ \w+/) {
        my $cd = nextLine();
        $line = nextLine();
        my @sources = extractOption($line, "-primary-file");
        my @objects = extractOption($line, "-o");
        # print "# $line\n@sources -- @objects\n\n";
        foreach my $i (0..$#sources) {
            my $object = $objects[$i];
            next if $rules{$object}++;
            $line =~ s/builtin-swiftTaskExecution -- |-frontend-parseable-output//g;
            print $MAKE "\n$object: $sources[$i]\n";
            print $MAKE "\t$cd\n\t$line && touch $object\n\n";
        }
    # Add rule to link executables
    } elsif (my ($executable) = $line =~ /^Ld (\S+?(?:\\.\S+?)*?) /) {
        my $cd = nextLine();
        $line = nextLine();
        my ($linkfile) = extractOption($line, "-filelist") or next;
        $linkfile =~ s/\\(.)/$1/g;
        print(">>> Link file: $linkfile\n");
        my $OBJS = IO::File->new("< $linkfile") or next;
        print $MAKE "\n$executable:";
        while (my $object = $OBJS->getline()) {
            chomp $object;
            $object =~ s/([ ])/\\$1/g;
            print $MAKE " $object";
        }
        print $MAKE "\n\t$cd\n\t$line";
        print $MAKE " && codesign -f -s - $executable\n\n";
        push @linked, $executable if $executable !~ /\.o$/;
    }
}

print $MAKE "main: @linked\n\n";
close $MAKE;
}

exit system("make") >> 8;
