#!/usr/bin/env perl -w
#
# "xcodemake"
#
# A short script to convert xcodebuild output into a Makefile.
# Once a Makefile has been generated you can use the much
# faster "make" command for most builds instead of launching
# the more ponderous xcodebuild for each iteration. Sure,
# this could be rewritten in python and use ninja instead.
#

use IO::File;
use strict;

my $log = "xcodebuild.log";
my $make = "Makefile";

if (! -f $log) {
    # Move Xcode's build database to one side to
    # be able to use xcodebuild inside a scheme.
    my $builddb = $ENV{OBJROOT};
    if ($builddb) {
        $builddb .= "/XCBuildData/build.db";
        rename $builddb, $builddb.".save";
    }

    my $xcodebin = $ENV{DEVELOPER_BIN_DIR}||'/usr/bin';
    my $archs = $ENV{ARCHS}||'arm64';
    my $args = join ' ', map { "'$_'" } @ARGV;
    my $build = "'$xcodebin'/xcodebuild clean; /usr/bin/env -i '$xcodebin'/xcodebuild ARCHS=$archs $args 2>&1 | tee $log";
    warn "Executing: $build\n";
    if (system $build) {
        unlink $log;
        exit 1;
    }
    unlink $make;
    
    rename $builddb.".save", $builddb if $builddb;
}

# Regenerate Makefile (if script newer)
if (! -f $make or -M $0 < -M $make) {
my $LOG = IO::File->new("< $log") or die "Could not open $log: $!";
my $MAKE = IO::File->new("> $make") or die "Could not open $make: $!";
my $identity = $ENV{EXPANDED_CODE_SIGN_IDENTITY} || '-';
print $MAKE "\ndefault: main\n\n";

# escape $ for make
sub dollarEscape {
    $_[0] =~ s/\\\$/\\\$\$/g;
}
# esacpe file path
sub pathEscape {
    $_[0] =~ s/([()])/\\$1/g;
    dollarEscape $_[0];
}

# regex for file path argument
my $notSpace = "[^\\\\\\s]";
my $fileArg = "$notSpace+(?:\\\\.$notSpace*)*";

sub nextLine {
    my $line = $LOG->getline() or return;
    chomp $line;
    return $line;
}

sub nextCD {
    my ($cd) = nextLine() =~ /cd (.*)/;
    $cd =~ s/\\([^\$'()&])/$1/g;
    $cd =~ s/([ ])/\\$1/g;
    dollarEscape $cd;
    return "\t\tcd $cd\n\t\t/usr/bin/time ";
}

# Extract values for the option from a command
sub extractOption {
    my ($line, $option) = @_;
    return my @a = $line =~ / $option ($fileArg)/g;
}

my (%rules, @linked);

while (defined(my $line = nextLine())) {
    print $MAKE "# $line\n";
    # Add rules for "C" family sources.
    if (my ($object, $source) = $line =~
        /^CompileC ($fileArg) ($fileArg) /) {
        my $cd = nextCD();
        do {
            $line = nextLine();
        } while ($line =~ /^\s*$|response file/);
        $object =~ s/\\([{}()])/$1/g;
        $object =~ s/([\$&])/\\$1/g;
        dollarEscape $source;
        $source =~ s/\\'/'/g;
        print $MAKE "\n$object: $source\n";
        pathEscape $object;
        dollarEscape $line;
        print $MAKE "$cd$line && touch $object\n\n";
    # Add rules for Swift sources (expand batches)
    } elsif ($line =~ /^SwiftCompile \w+ \w+/) {
        my $cd = nextCD();
        ($line = nextLine()) =~ s/builtin-swiftTaskExecution -- |-frontend-parseable-output//g;
        my @sources = extractOption($line, "-primary-file");
        my @objects = extractOption($line, "-o");
        # print "# $line\n@sources -- @objects\n\n";
        dollarEscape $line;
        foreach my $i (0..$#sources) {
            (my $object = $objects[$i]) =~ s/\\([{}()])/$1/g;
            $sources[$i] =~ s/\\([\$'&{}()*])/$1/g;
            $sources[$i] =~ s/\$/\$\$/g;
            next if $rules{$object}++;
            print $MAKE "\n$object: $sources[$i]\n";
            pathEscape $object;
            print $MAKE "$cd$line && touch $object\n\n";
        }
    # Add rule to link executables
    } elsif (my ($executable) = $line =~ /^Ld ($fileArg) /) {
        my $cd = nextCD();
        $line = nextLine();
        my ($linkfile) = extractOption($line, "-filelist") or next;
        $linkfile =~ s/\\(.)/$1/g;
        print(">>> $executable Link file: $linkfile\n");
        my $OBJS = IO::File->new("< $linkfile") or next;
        $executable =~ s/([&\$])/\\$1/g;
        print $MAKE "\n$executable:";
        while (my $object = $OBJS->getline()) {
            chomp $object;
            $object =~ s/([ '&\$])/\\$1/g;
            next if $object eq $executable || !$rules{$object};
            print $MAKE " $object";
        }
        dollarEscape $line;
        print $MAKE "\n$cd$line";
        pathEscape my $tosign = $executable;
        print $MAKE " && codesign -f -s '$identity' $tosign\n\n";
        push @linked, $executable if $executable !~ /\.o$/;
    }
}

print $MAKE "main: @linked\n\n";
close $MAKE;
}

exit system("make") >> 8;
